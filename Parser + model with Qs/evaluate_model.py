from RMSDcalc import RMSDcalc
import aria_parser as ap
import numpy as np
from amplpy import AMPL, Environment, DataFrame, add_to_path
import Bio.PDB as PDB
from scipy.spatial import distance_matrix
import math

def process_res(file: str, AA_info: ap.ResInfoDict, run_file: str) -> dict:
    """Input: file - PDB file
              AA_info - AA_infor dict as generated by the function parse.top in aria
    
       Output: dictionary with avergage RMSD between input file and model ouput for simulated NOE-data 
       for amino acids in PDB file  
    """
    pdbparser = PDB.PDBParser(QUIET=True) 
    struct = pdbparser.get_structure(file.split('.')[0], file)

    total_RMSD = dict()
    num_AA = dict()

    for model in struct:
        for chain in model:
            for res in chain:
                print(f'Seg id:{res.get_segid()}')
                res_name = res.get_resname()
                atoms = res.get_atoms()
                atom_list, coord_list = NOE_data_from_res(atoms, res_name, AA_info) #writes to file
                Xr = run_model(run_file)
                X0 = [x for _, x in sorted(zip(atom_list, coord_list), key=lambda pair: pair[0])]
                X0 = np.array(X0)

                _, _, RMSD = RMSDcalc(X0, Xr)

                if total_RMSD.get(res_name) : 
                    total_RMSD[res_name] += RMSD
                    num_AA[res_name] += 1
                else: 
                    total_RMSD[res_name] = RMSD
                    num_AA[res_name] = 1
    
    avg_rmsd = {AA : RMSD/num_AA[AA] for AA, RMSD in total_RMSD.items()}
    return avg_rmsd

def NOE_data_from_res(atoms, AA_name: str, AA_info: ap.ResInfoDict) -> tuple[list, list]:
    """Input: atoms - list (?) of atoms as given by Bio.PDB.resiude module
              AA_name: Name of AA that is being processed
              AA_info: AA_info dict as given by the parse_top function from the aria_parser
              
        Output: atom_list: list of atoms in resiude, with name corrected to match aria nomenclature
                coord_list: list of coordinates from eah atom in atom list
                
        Computes simulated NOE data for the given resiude
    """

    seq, non_h, cov_lens, angle_lens = AA_info[AA_name]
    atom_list = []
    coord_list = []

    for a in atoms:
        name, coord = a.get_name(), a.get_coord()
        if name not in seq and name not in non_h:
            if name == "H": 
                atom_list.append("HN")
                coord_list.append(coord)
            elif name[-1].isdigit() and f'{name[:-1]}{int(name[-1])-2}' in seq:
                m = len(atom_list)
                atom_list.append(f'{name[:-1]}{int(name[-1])-1}')
                atom_list[m-1] = f'{name[:-1]}{int(name[-1])-2}'
            else:
                atom_list.append(name)
                coord_list.append(coord) 
        else:
            atom_list.append(name)
            coord_list.append(coord)

    atoms_by_res = {1: set(a for a in atom_list)}

    n = len(coord_list)
    k = len(coord_list[0])

    NOE_assignment = []

    for i in range(n):
        if atom_list[i][0] != "H": continue
        for j in range(i+1, n):            
            if atom_list[j][0] != "H": continue
            a , b = coord_list[i], coord_list[j]
            dist = sum((a[l] - b[l])**2 for l in range(k))
            NOE_assignment.append(( [], [atom_list[i]], [atom_list[j]], 1/dist**6 ))
    
    cov_dists, angle_dists = dict(), dict()

    for (a1, a2), dist in cov_lens.items():
        if a1 in atom_list and a2 in atom_list:
            cov_dists[a1, a2] = dist
    
    for (a1, a2), dist in angle_lens.items():
        if a1 in atom_list and a2 in atom_list:
            angle_dists[a1, a2] = dist

    ap.write_data(atoms_by_res, NOE_assignment, cov_dists, angle_dists, dict(), "model/RES_data.dat", scale_factor=1)
    return atom_list, coord_list

def NOE_data_from_prot(atom_list: list , coord_list: list) -> ap.NOEAssignment:

    rhos = []
    n = len(coord_list[0])

    pair_dist = distance_matrix(coord_list, coord_list)
    ids = np.argwhere(pair_dist < 6)
    for pair in ids:
        a, b = pair
        if a > b:
            continue
        if a == b:
            continue  
        dist = pair_dist[a, b]
        if atom_list[a][0] == "H" and atom_list[b][0] == "H":
            rhos.append(([], [atom_list[a]], [atom_list[b]], 1/dist**6))
    return rhos

def run_model(run_file) -> np.array:
    """Input: 

       Output: Xr - np.array for RMSD calculation

       Runs the AMPL model, find the vectore Xr
    """
    
    add_to_path(r"/Users/anjamatic/ampl") 
    ampl = AMPL()
    ampl.read(run_file)
    X = ampl.get_data("x").to_pandas()
    atoms, X_temp = [], []
    crnt_coord = []
    
    for index, row in X.iterrows():
        (a, pos), coord = index, row["x"]
        if a not in atoms:
           atoms.append(a)
        if pos == 3:
            crnt_coord.append(coord)
            X_temp.append(crnt_coord)
            crnt_coord = []
        else: 
            crnt_coord.append(coord)

    Xr = [x for _, x in sorted(zip(atoms, X_temp), key=lambda pair: pair[0])]
    Xr = np.array(Xr)
    return Xr

def process_prot(file: str, AA_info, run_file: str, datafilename="model/prot_data.dat", num_AA = math.inf) -> float:
    #https://stackoverflow.com/questions/54616078/large-set-of-x-y-coordinates-efficient-way-to-find-any-within-certain-distance

    pdbparser = PDB.PDBParser(QUIET=True) 
    struct = pdbparser.get_structure(file.split('.')[0], file)
    
    atom_list, coord_list = [], []
    atoms_by_res = dict()
    res_id_to_AA = dict()

    num_models = 0
    total_RMSD = 0

    res_id = 0
    atom_name = ""
    atom_set = set()

    for model in struct:
        num_models += 1
        res_id = 0
        for chain in model:   
            for res in chain:
                res_id += 1
                res_name = res.get_resname()
                seq, non_h, _, _ = AA_info[res_name]
                for a in res:
                    name, coord = a.get_name(), a.get_coord()
                    if name not in seq and name not in non_h:
                        if name == "H":
                            atom_name = f'HN_{res_id}' 
                        elif name[-1].isdigit() and f'{name[:-1]}{int(name[-1])-2}' in seq:
                            atom_name = f'{name[:-1]}{int(name[-1])-1}_{res_id}'
                            m = len(atom_list)
                            atom_list[m-1] = f'{name[:-1]}{int(name[-1])-2}_{res_id}'
                            atom_set.add(f'{name[:-1]}{int(name[-1])-2}_{res_id}')
                        else:
                            atom_name = f'{name}_{res_id}'
                    else:
                        atom_name = f'{name}_{res_id}'

                    atom_list.append(atom_name)
                    atom_set.add(atom_name)
                    coord_list.append(coord)
                
                atoms_by_res[res_id] = atom_set
                res_id_to_AA[res_id] = res_name
                atom_set = set()
                if res_id == num_AA: 
                    break
            if res_id == num_AA: 
                break

        res_id = 0
        cov_dists, ang_dists = ap.compute_dists(atoms_by_res, AA_info, res_id_to_AA)
        rhos = NOE_data_from_prot(atom_list, coord_list)
        ap.write_data(atoms_by_res, rhos, cov_dists, ang_dists, dict(), filename=datafilename, scale_factor=1)
        Xr = run_model(run_file)
        X0 = [x for _, x in sorted(zip(atom_list, coord_list), key=lambda pair: pair[0])]
        X0 = np.array(X0)

        print(X0, Xr)

        _, _, RMSD = RMSDcalc(X0, Xr)

        total_RMSD += RMSD
    
    return total_RMSD/num_models
        
#with open("data/aria.par", "r") as stream : 
#   par_content = stream.read()
#cov_lengths, angle_lengths = ap.parse_par(par_content)

#with open("data/aria.top", "r") as stream:
#   top_content = stream.read()

#res_info_dict = ap.parse_top(top_content, cov_lengths, angle_lengths)


#RMSD = process_prot("/Users/anjamatic/AriaParser/test.pdb", res_info_dict, num_AA = 2, run_file="")
#print(RMSD)

